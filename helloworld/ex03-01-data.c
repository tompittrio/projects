/*
파일명 : ex03-01-data.c
데이터 표현방식
    정수표현
        컴퓨터는 2진수로 표현(bit)
        부호비트(MSB:Most Significant Bit 최상위 비트를 의미 lsb도 있음) + 수치비트
        음의값을 표현할 때 2의 보수표현
            플러수 3은 2진수로 11 인데
            -3은 2진수로 2의 보수로 표현된다.

    실수표현(부동소수)
        지수부(e)비트 + 가수부(m)비트
    실수표현 수식
        ±(1.m)*2^(e-127)
    부동소수점오차
        정확한 실수표현 불가능으로 근사치값으로 인해 생긴 오차
            이것은 모든 컴퓨터(언어가) 동일함
            따라서 이것에 대한 예외처리가 반드시 있어야 함.
                코드와 정책으로 해결 방법을 찾아야 함. (보통 절삭 또는 반올림으로 처리)
    unsigned 자료형
        부호없는 데이터
        0이상 표현
        음수표기 대신 양수 표현 범위 그만큼 커진다.



    31.4가 있다면
    ㅣ0ㅣ0ㅣ3ㅣ1ㅣ*ㅣ*ㅣ*ㅣ*ㅣ    - 고정소수점 방식 (자릿수를 무한정 늘리다면 문제)
     msb 소수점위  소수점아래
     이것을 부동소수 방식으로 표현하면
     msb + 지수부에 자릿수를 표현하고 + 가수부에는 값을 넣어서 표현
     이것의문제는 0을 표현하지 못함     지수부 가수부 둘다 0을 넣어도 0이 나오지 않음 그래서 실수 표현에 0.*이 안나옴
     이 때의 문제를 예제로 살펴보자



*/

#include <stdio.h>
int main(void)
{
    // float일때 최종값은 10.000002 (오차확인 가능) 
    // double 일때 도 오차 있음 (컴퓨터는 실수 표현 정확하게 하지 못함, float이 그나마 근사치로 가는 것 뿐)
    // 그래서 실수에서는 범위가 큰것을 사용하는 것이 좋음
    float err_num = 0; //0표현 못해도 알아서 뒤에 값을 버려줘 하지만 0.00001같은 어떤 값이 계속 쌓이면 27번째 값에서 버리지 못함 결국에는 오차가 생김
    for (int i = 0; i < 100; i++) // for 명령어는 코드를 반복하라는 뜻, 첫번째 선언, 조건, 할 일 i++ = i+1, 코드는 아래에 써있음
    {
        err_num += 0.1;
        printf("%d번째: %f\n", i, err_num);
    }

  
    char cnum = 128; // char범위가 127까지지만 128로 표현하면 (오버플로우 되서 -128로 나옴)
    unsigned char u_cnum = 255;
    short snum = 32768; // short형 의 최대 값은 32767이다.    
    unsigned short u_snum = 32768; // short형 의 최대 값은 32767이다.    
    printf ("%d\n", cnum);
    printf ("%d\n", u_cnum);
    printf ("%d\n", snum);
    printf ("%d\n", u_snum);


    // NOT연산자 2의 보수관련 예시
    // 1의 보수는 비트 반전(양수일때는 캐리값 뒤에 더하기) -> 2의 보수는 1의 보수의 +1 (캐리값 버리기) (음수는 방법이 다름)
    printf("~5: %d\n", ~5); //데이터 앞의 물결표시는 not 연산자이고 이건 부호가 반전이된다.
    // 5=00101 이 11010이 된다.
    /* 왜 마이너스 6이되나? 컴퓨터는 연산을 할 때 뺄샘이 안됨.
    5-3=2를
    5+(-3)=2 로 표현
     보수란 값의 표현을 다 반대로 함
     3의 2진수 0101 에 1의 보수로 1010 을 더해서 앞의 캐리 값이 있음, 캐리값을 뒤로 돌려 더하면 값이 나옴
    이 때의 문제는 모든 수가 뺄샘이 가능해야 하는데, 0의1의 보수는 0000, 1111 둘다 가능하지만 메모리 차지하고 효율이 떨어지니 2의 보수를 찾음
    2의 보수는 (1의보수+1 이다. 단 2의 보수 캐리값은 버린다.)

    2의 보수 계산
    -6 -> 2진수 0110 -> 보수 1001 -> 부호값도 1로 바뀜 -> 1010이 최종값이 됨.



    */
    return 0;



}

